---
layout: post
title: Finding Median in (Almost) Linear Time
date: '2011-03-23T14:52:00.000-06:00'
author: Cory Hardman
tags:
- Development
modified_time: '2012-04-21T09:22:56.921-06:00'
blogger_id: tag:blogger.com,1999:blog-880694922178002855.post-8677778571284735995
blogger_orig_url: https://www.coryhardman.com/2011/03/finding-median-in-almost-linear-time.html
---

I sometimes find myself needing to find the median of a set of numbers. What I would do was sort the list of numbers and then take the value in the middle index, something like(in Java):<br/><pre lang="java">    public static int FindMedian(List &lt;Integer&gt; nums)<br/>    {<br/>        Collections.sort(nums);<br/>        if(nums.size() % 2 == 0)<br/>        {<br/>             return (nums.get(nums.size() / 2) + nums.get((nums.size() / 2) + 1)) / 2;<br/>        }<br/>        return nums.get(nums.size() / 2);<br/>    }</pre><br/>This solution is on the order of O(n lg n) where n is the number of elements. A faster method would be use a modified <a href="http://en.wikipedia.org/wiki/Quicksort">quick sort</a>. The idea being that after each partition we gain some knowledge about how many numbers are less than or equal to a given number in the list. So we can be smart and only iterate on the side of the list where we know the selected number is. Here is my implementation of QuickSelect in Java:<br/><pre lang="java"><br/>public class QuickSelect {<br/>    public static < T extends Comparable <? super T>> T quickSelect(List < T > values, int k)<br/>    {<br/>        int left = 0;<br/>        int right = values.size() - 1;<br/>        Random rand = new Random();<br/>        while(true)<br/>        {<br/>            int partionIndex = rand.nextInt(right - left + 1) + left;<br/>            int newIndex = partition(values, left, right, partionIndex);<br/>            int q = newIndex - left + 1;<br/>            if(k == q)<br/>            {<br/>                return values.get(newIndex);<br/>            }<br/>            else if(k < q)<br/>            {<br/>                right = newIndex - 1;<br/>            }<br/>            else<br/>            {<br/>                k -= q;<br/>                left = newIndex + 1;<br/>            }<br/>        }<br/>    }<br/>    private static < T extends Comparable<? super T>> int partition(List < T > values, int left, int right, int partitionIndex)<br/>    {<br/>        T partionValue = values.get(partitionIndex);<br/>        int newIndex = left;<br/>        T temp = values.get(partitionIndex);<br/>        values.set(partitionIndex, values.get(right));<br/>        values.set(right, temp);<br/>        for(int i = left; i < right; i++)<br/>        {<br/>            if(values.get(i).compareTo(partionValue) < 0)<br/>            {<br/>                temp = values.get(i);<br/>                values.set(i, values.get(newIndex));<br/>                values.set(newIndex, temp);<br/>                newIndex++;<br/>            }<br/>        }<br/>        temp = values.get(right);<br/>        values.set(right, values.get(newIndex));<br/>        values.set(newIndex, temp);<br/>        return newIndex;<br/>    }<br/>}<br/></pre><br/>From here implementing FindMedian should be pretty straight forward. The nice thing about this algorithm is that it can find any kth largest number in a set. Plus on average this will run in O(n) with a worst case of O(n lg n). Enjoy!</pre>